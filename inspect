#!/usr/bin/env python

import os
import sys
import glob
import argparse
import traceback
import shutil
from datetime import datetime
from subprocess import Popen, PIPE, CalledProcessError, check_call

from termcolor import colored

PATH = os.path.dirname(os.path.abspath(__file__))
SCRIPTS = os.environ.get("ZI_SCRIPTS") or os.path.join(PATH, "scripts")
RESULTS = os.environ.get("ZI_RESULTS") or "inspected-%s" % datetime.today().isoformat().replace(":", "-")
LOGFILE = os.path.join(RESULTS, "inspector.log")

ZI_TAGS = "zenoss-inspector-tags"
ZI_DEPS = "zenoss-inspector-deps"
ZI_INFO = "zenoss-inspector-info"

class Script(object):

    def __init__(self, script):
        self.script = script
        self.basename = os.path.basename(script)
        self.tags = []
        self.load_tags()
        self.deps = []
        self.load_dependencies()
        self.info = self.get_info_tag()

    def load_tags(self):
        with open(self.script, 'r') as f:
            lines = f.readlines()
        for line in lines:
            if ZI_TAGS in line:
                self.tags = line[line.index(ZI_TAGS) + len(ZI_TAGS):].strip().split()
                return

    def load_dependencies(self):
        with open(self.script, 'r') as f:
            lines = f.readlines()
        for line in lines:
            if ZI_DEPS in line:
                self.deps = line[line.index(ZI_DEPS) + len(ZI_DEPS):].strip().split()
                return

    def get_info_tag(self):
        with open(self.script, 'r') as f:
            raw = ''.join(f.readlines())
        if ZI_INFO in raw:
            return True
        return False

    def run(self):
        p = Popen(self.script, stdout=PIPE, stderr=PIPE, cwd=RESULTS)
        stdout, stderr = p.communicate()
        return stdout, stderr, p.returncode

    def store_result(self, stdout, stderr, result_path):
        fout = os.path.join(result_path, self.basename + ".stdout")
        with open(fout, 'w') as f:
            f.write(stdout)
        if len(stderr) > 0:
            ferr = os.path.join(result_path, self.basename + ".stderr")
            with open(ferr, 'w') as f:
                f.write(stderr)


def log(msg, color=None, attrs=None, end=True, tty=True):
    # Logic here could be cleaner, but I'm in a hurry.
    if sys.stdout.isatty():
        fmtd = colored(msg, color, attrs=attrs)
    else:
        fmtd = msg
    if end and tty:
        print fmtd
    elif tty:
        print fmtd,
    with open(LOGFILE, 'a') as f:
        if end:
            msg += "\n"
        f.write(msg.encode("utf-8"))
    sys.stdout.flush()

def get_scripts():
    paths = glob.glob(os.path.join(SCRIPTS, "*"))
    return [Script(s) for s in paths if os.path.isfile(s)]

def get_args():
    parser = argparse.ArgumentParser(description="Inspect a Zenoss installation.")
    parser.add_argument("--no-remove", action="store_true", default=False,
                        help="Don't remove untarred directory.")
    parser.add_argument("--no-save", action="store_true", default=False,
                        help="Don't compress results.")
    tags = parser.add_mutually_exclusive_group()
    tags.add_argument("-w", "--whitelist", nargs="+", help="Use only these tags.")
    tags.add_argument("-b", "--blacklist", nargs="+", help="Don't use these tags.")
    return parser.parse_args()

def main():
    args = get_args()
    scripts = get_scripts()

    if args.whitelist:
        scripts = [s for s in scripts if any(t in args.whitelist for t in s.tags)]
    elif args.blacklist:
        scripts = [s for s in scripts if not any(t in args.blacklist for t in s.tags)]

    padding = max([len(s.basename) for s in scripts]) + 4

    os.mkdir(RESULTS)

    completed_scriptnames = []

    last_len = None

    while len(scripts) > 0:

        # Detect circular dependencies.
        if len(scripts) == last_len:
            log("Circular dependency detected, aborting.", "red", attrs=["bold"])
            log(' '.join(s.basename for s in scripts), "red")
            break
        last_len = len(scripts)

        for script in scripts[:]:

            # Make a list of all scripts that have been run successfully and that are planned to run.
            all_scripts = completed_scriptnames + [s.basename for s in scripts]

            # If the deps for this script will never be met, remove it from the list and continue
            # to the next.
            if not all(d in all_scripts for d in script.deps):
                print script.basename, script.deps, all_scripts
                scripts.remove(script)
                continue

            # If we haven't met the deps for this script yet, continue to the next one.
            if not all(d in completed_scriptnames for d in script.deps):
                continue

            # All deps met, let's run this script. No matter what happens next, we don't want this
            # in our to-exectute script list anymore.
            scripts.remove(script)

            log(script.basename.ljust(padding), "blue", end=False)

            # Run the script.
            stdout, stderr, retcode = script.run()

            # Indicate script pass/fail.
            if retcode == 0:
                log("done", "blue")
            else:
                log("X", "red")

            if script.info:
                if len(stdout) > 0:
                    log(stdout.strip(), "red")
                if len(stderr) > 0:
                    log("Error running %s" % script.basename, "red", attrs=["bold"])
                    log(stderr.strip(), "red")
            else:
                script.store_result(stdout, stderr, RESULTS)

            if retcode == 0:
                completed_scriptnames.append(script.basename)

    if not args.no_save:
        log("Compressing results: %s" % RESULTS + ".tar.gz", "blue", attrs=["bold"])
        check_call(["tar", "-czf", RESULTS + ".tar.gz", RESULTS])

    if not args.no_remove:
        log("Cleaning up...", "blue", attrs=["bold"])
        shutil.rmtree(RESULTS)


if __name__ == "__main__":
    main()
