#!/usr/bin/env python

import os
import sys
import glob
import argparse
import traceback
import shutil
from datetime import datetime

from termcolor import colored
from script import Script

PATH = os.path.dirname(os.path.abspath(__file__))
SCRIPTS = os.environ.get("ZI_SCRIPTS") or os.path.join(PATH, "scripts")
RESULTS = os.environ.get("ZI_RESULTS") or "inspected-%s" % datetime.today().isoformat().replace(":", "-")
LOGFILE = os.path.join(RESULTS, "inspector.log")

def log(msg, color=None, attrs=None, end=True, tty=True):
    # Logic here could be cleaner, but I'm in a hurry.
    if sys.stdout.isatty():
        fmtd = colored(msg, color, attrs=attrs)
    else:
        fmtd = msg
    if end and tty:
        print fmtd
    elif tty:
        print fmtd,
    with open(LOGFILE, 'a') as f:
        if end:
            msg += "\n"
        f.write(msg.encode("utf-8"))
    sys.stdout.flush()

def get_scripts():
    paths = glob.glob(os.path.join(SCRIPTS, "*"))
    return [Script(s) for s in paths if os.path.isfile(s)]

def get_args():
    parser = argparse.ArgumentParser(description="Inspect a Zenoss installation.")
    parser.add_argument("--no-remove", action="store_true", default=False,
                        help="Don't remove untarred directory.")
    parser.add_argument("--no-save", action="store_true", default=False,
                        help="Don't compress results.")
    tags = parser.add_mutually_exclusive_group()
    tags.add_argument("-w", "--whitelist", nargs="+", help="Use only these tags.")
    tags.add_argument("-b", "--blacklist", nargs="+", help="Don't use these tags.")
    return parser.parse_args()

def main():
    args = get_args()
    scripts = get_scripts()

    if args.whitelist:
        scripts = [s for s in scripts if any(t in args.whitelist for t in s.tags)]
    elif args.blacklist:
        scripts = [s for s in scripts if not any(t in args.blacklist for t in s.tags)]

    padding = max([len(s.basename) for s in scripts]) + 4

    os.mkdir(RESULTS)

    completed_scriptnames = []

    last_len = None

    while len(scripts) > 0:

        # Detect circular dependencies.
        if len(scripts) == last_len:
            log("Circular dependency detected, aborting.", "red", attrs=["bold"])
            log(' '.join(s.basename for s in scripts), "red")
            break
        last_len = len(scripts)

        for script in scripts[:]:

            # Make a list of all scripts that have been run successfully and that are planned to run.
            all_scripts = completed_scriptnames + [s.basename for s in scripts]

            # If the deps for this script will never be met, remove it from the list and continue
            # to the next.
            if not all(d in all_scripts for d in script.deps):
                print script.basename, script.deps, all_scripts
                scripts.remove(script)
                continue

            # If we haven't met the deps for this script yet, continue to the next one.
            if not all(d in completed_scriptnames for d in script.deps):
                continue

            # All deps met, let's run this script. No matter what happens next, we don't want this
            # in our to-exectute script list anymore.
            scripts.remove(script)

            log(script.basename.ljust(padding), "blue", end=False)

            # Run the script.
            stdout, stderr, retcode = script.run(RESULTS)

            # Indicate script pass/fail.
            if retcode == 0:
                log("done", "blue")
            else:
                log("X", "red")

            if script.info:
                if len(stdout) > 0:
                    log(stdout.strip(), "red")
                if len(stderr) > 0:
                    log("Error running %s" % script.basename, "red", attrs=["bold"])
                    log(stderr.strip(), "red")
            else:
                script.store_result(stdout, stderr, RESULTS)

            if retcode == 0:
                completed_scriptnames.append(script.basename)

    if not args.no_save:
        log("Compressing results: %s" % RESULTS + ".tar.gz", "blue", attrs=["bold"])
        check_call(["tar", "-czf", RESULTS + ".tar.gz", RESULTS])

    if not args.no_remove:
        log("Cleaning up...", "blue", attrs=["bold"])
        shutil.rmtree(RESULTS)


if __name__ == "__main__":
    main()
